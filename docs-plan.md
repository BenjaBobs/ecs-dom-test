# Documentation Site — Homebrew ECS Approach

## Context

Astro/Starlight proved fragile (content collection bugs, TypeDoc plugin conflicts, opaque errors). We're going fully custom: the doc site itself is an ECS application built with the framework it documents. This gives us:

- **Maximum dogfooding**: sidebar, navigation, theme, search — all ECS entities and systems
- **Debug UI on every page**: users toggle the inspector and see how a real ECS app works
- **Full control**: no third-party framework bugs, no dependency on Astro's content collections
- **MDX content**: hand-written guides and API reference compiled to HTML at build time

## Architecture Overview

```
Build Time (Bun scripts)                    Client Side (ECS App)
─────────────────────────                   ────────────────────────

 .mdx files ──→ frontmatter + HTML body     World
                                             ├─ PageShell (layout grid)
 TypeDoc ──→ API .md files ──→ same         │   ├─ Sidebar (nav tree)
                                             │   ├─ TopBar (title, theme, search)
 Navigation tree from frontmatter            │   ├─ ContentArea (injected HTML)
                                             │   └─ BottomNav (prev/next)
 ECS client app ──→ bundled JS              │
                                             ├─ ThemeState (light/dark)
 HTML template + page data ──→ static HTML  ├─ SearchIndex (client-side)
                                             └─ DebugUI (toggle-able)
```

### Build Pipeline

```
1. Discover .mdx/.md files in content/
2. Parse frontmatter (gray-matter) → build sidebar tree + page metadata
3. Compile MDX → HTML strings (@mdx-js/mdx + preact + shiki)
4. Generate TypeDoc API reference → markdown → compile same way
5. Bundle client-side ECS app (esbuild (todo: why not bun?), TSX → single JS bundle)
6. Bundle playground modules
7. For each page: inject content HTML + metadata into HTML template
8. Write static files to dist/
```

### Client-Side ECS App

The entire page shell is an ECS application:

- **Entities**: sidebar items, nav links, content area, theme toggle, search input
- **Systems**: SidebarSystem (expand/collapse, active highlighting), ThemeSystem (persist to localStorage, toggle classes), ContentSystem (inject pre-rendered HTML), SearchSystem (filter pages)
- **Debug UI**: `createDebugUI(world)` mounted on every page — users can toggle it to inspect the doc site's own ECS state

Pre-rendered content HTML is embedded in each page as a `<script type="application/json">` block. The ECS app reads it and injects it into the content area entity's DOM element.

---

## Directory Structure

```
apps/docs/
├── build/                          # Build-time scripts (Bun)
│   ├── build.ts                    # Main build orchestrator
│   ├── compile-mdx.ts              # MDX → HTML compilation
│   ├── generate-nav.ts             # Frontmatter → sidebar tree
│   ├── generate-api-docs.ts        # TypeDoc → markdown → compile
│   └── template.ts                 # HTML page template
│
├── src/                            # Client-side ECS app (bundled)
│   ├── main.tsx                    # Entry: create World, register systems, build shell
│   ├── components/                 # ECS components for the doc site
│   │   ├── navigation.ts           # SidebarItem, NavLink, ActivePage, etc.
│   │   ├── content.ts              # PageContent (raw HTML), PageTitle, etc.
│   │   ├── theme.ts                # ThemeState, ThemeToggle
│   │   └── search.ts               # SearchIndex, SearchQuery, SearchResults
│   ├── systems/                    # ECS systems for the doc site
│   │   ├── sidebar-system.ts       # Expand/collapse, active highlighting
│   │   ├── content-system.ts       # Inject HTML into content area
│   │   ├── theme-system.ts         # Dark/light toggle, localStorage
│   │   ├── search-system.ts        # Client-side page search
│   │   └── bottom-nav-system.ts    # Previous/next page links
│   └── bundles/                    # Reusable entity patterns
│       ├── nav-item.tsx            # Sidebar navigation item
│       └── icon-button.tsx         # Button with icon
│
├── content/                        # MDX/MD source files
│   ├── index.mdx                   # Landing page
│   ├── guides/
│   │   ├── getting-started.mdx
│   │   ├── core-concepts.mdx
│   │   └── design-choices.mdx
│   ├── examples/
│   │   └── index.mdx               # Interactive playgrounds
│   └── api/                        # Auto-generated by TypeDoc
│       └── (generated .md files)
│
├── public/                         # Static assets (copied to dist/)
│   ├── playground/
│   │   ├── frame.html              # Playground iframe
│   │   └── modules/                # Pre-bundled ECS packages
│   └── styles/
│       └── base.css                # Base styles, CSS custom properties, typography
│
├── dist/                           # Build output (gitignored)
│
├── package.json
└── tsconfig.json
```

---

## Phase 1: Build Pipeline

### 1a. MDX Compilation (`build/compile-mdx.ts`)

**Dependencies**: `@mdx-js/mdx`, `gray-matter`, `rehype-pretty-code`, `shiki`, `remark-frontmatter`, `remark-gfm`

Pipeline per file:
1. Read `.mdx` file
2. Extract frontmatter with `gray-matter` → `{ title, description, sidebar: { order, group } }`
3. Compile MDX with `@mdx-js/mdx`:
   - `outputFormat: 'function-body'`
   - `remarkPlugins`: `remark-frontmatter`, `remark-gfm`
   - `rehypePlugins`: `rehype-pretty-code` with shiki (build-time syntax highlighting, zero client JS)
4. Render to HTML string (todo: figure out how)

Custom MDX components provided at render time:
- `Playground` → renders `<div data-playground data-code="...">` placeholder (hydrated client-side)
- `Callout` / `Note` → simple HTML wrappers with CSS classes

### 1b. Navigation Generation (`build/generate-nav.ts`)

From parsed frontmatter, build a sidebar tree:
```ts
type NavItem = {
  title: string;
  slug: string;
  order: number;
  group?: string;
  children?: NavItem[];
};
```

Groups derived from directory structure: `guides/`, `examples/`, `api/`.

### 1c. TypeDoc API Reference (`build/generate-api-docs.ts`)

- Run TypeDoc with `entryPointStrategy: 'packages'` and `typedoc-plugin-markdown`
- Output markdown files to `content/api/`
- These get compiled through the same MDX pipeline as hand-written content

### 1d. HTML Template (`build/template.ts`)

Each page gets a complete HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>${title} — ECS UI Framework</title>
  <meta name="description" content="${description}" />
  <link rel="stylesheet" href="/styles/base.css" />
</head>
<body>
  <div id="root"></div>

  <!-- Pre-rendered content + metadata for the ECS app to consume -->
  <script type="application/json" id="page-data">
    {
      "title": "${title}",
      "content": "${escapedHtmlContent}",
      "sidebar": ${sidebarJson},
      "slug": "${slug}",
      "prev": ${prevJson},
      "next": ${nextJson}
    }
  </script>

  <!-- Client-side ECS app -->
  <script type="module" src="/app.js"></script>
</body>
</html>
```

### 1e. Build Orchestrator (`build/build.ts`)

```
bun run build/build.ts
  1. Clean dist/
  2. Run TypeDoc → content/api/
  3. Discover all .mdx/.md in content/
  4. Parse frontmatter → build nav tree
  5. Compile all pages → HTML strings
  6. Bundle client ECS app (esbuild: src/main.tsx → dist/app.js)
  7. Bundle playground modules
  8. Copy public/ → dist/
  9. Generate HTML pages → dist/
  10. Generate search index JSON → dist/search-index.json
```

---

## Phase 2: Client-Side ECS App

### 2a. Entry Point (`src/main.tsx`)

```tsx
import { World, Entity, materialize } from '@ecs-test/ecs';
import { registerDOMSystems, createDebugUI, registerDebugUISystems } from '@ecs-test/dom';

// Read page data injected by build
const pageData = JSON.parse(document.getElementById('page-data')!.textContent!);

const world = new World({
  externals: {
    createElement: document.createElement.bind(document),
    rootContainer: document.getElementById('root')!,
    window,
    console,
  },
});

registerDOMSystems(world);
registerDebugUISystems(world);
// Register doc-site systems (sidebar, theme, content, search)

const ui = (
  <Entity> {/* PageShell */}
    <Entity> {/* TopBar: title, theme toggle, search */} </Entity>
    <Entity> {/* Sidebar: nav tree */} </Entity>
    <Entity> {/* ContentArea: injected HTML */} </Entity>
    <Entity> {/* BottomNav: prev/next */} </Entity>
  </Entity>
);

materialize(world, ui);
createDebugUI(world);
world.flush();
```

### 2b. Key Components

| Component      | Data                               | Purpose                               |
| -------------- | ---------------------------------- | ------------------------------------- |
| `PageContent`  | `{ html: string }`                 | Pre-rendered MDX HTML to inject       |
| `PageTitle`    | `{ value: string }`                | Current page title                    |
| `SidebarItem`  | `{ title, slug, order, expanded }` | Nav tree node                         |
| `ActivePage`   | marker                             | Marks the current page's sidebar item |
| `ThemeState`   | `{ mode: 'light' \| 'dark' }`      | Current theme                         |
| `SearchQuery`  | `{ value: string }`                | Current search input                  |
| `SearchResult` | `{ title, slug, excerpt }`         | Matching pages                        |

### 2c. Key Systems

| System             | Query                                  | Behavior                                                       |
| ------------------ | -------------------------------------- | -------------------------------------------------------------- |
| `ContentSystem`    | `with([PageContent, DOMElement])`      | Sets `innerHTML` from `PageContent.html`                       |
| `SidebarSystem`    | `with([SidebarItem, DOMElement])`      | Highlights active item, handles expand/collapse                |
| `ThemeSystem`      | `with([ThemeState])`                   | Toggles `data-theme` on `<html>`, persists to localStorage     |
| `SearchSystem`     | `with([SearchQuery])`                  | Filters search index, creates/removes SearchResult entities    |
| `BottomNavSystem`  | `with([BottomNav, DOMElement])`        | Updates prev/next links based on sidebar order                 |
| `PlaygroundSystem` | `with([PlaygroundMarker, DOMElement])` | Hydrates `[data-playground]` elements with CodeMirror + iframe |

### 2d. Playground Hydration

The build renders `<div data-playground data-code="...">` placeholders. The client-side `PlaygroundSystem` finds these DOM elements and initializes the CodeMirror + iframe pipeline.

### 2e. Debug UI

`createDebugUI(world)` is called on every page. Users toggle it with a hotkey (e.g., `Ctrl+Shift+D`) to inspect the doc site's ECS state — entities, components, systems, mutations. This is the primary dogfooding showcase.

---

## Phase 3: Dev Server

A `build/dev.ts` script using `Bun.serve()`:

1. Runs the full build once
2. Starts an HTTP server serving `dist/`
3. Watches `content/` and `src/` for changes:
   - Content change → recompile affected page(s) only
   - Client code change → rebundle ECS app
4. Injects a livereload script in dev mode (WebSocket-based)

---

## Phase 4: Versioning (Deferred)

When approaching v1.0:
- Git-tag-based versioning: build script reads tag, outputs to `dist/v1/`, `dist/v2/`, etc.
- Version selector dropdown in the ECS shell's top bar
- Current version served at root, older versions at `/v1/`, `/v2/`

---

## Phase 5: CI/CD (GitHub Pages)

TODO: figure out how, and what I need to do on the github page to set it up

---

## New Dependencies

| Package                   | Purpose                                                                                 | Size                   |
| ------------------------- | --------------------------------------------------------------------------------------- | ---------------------- |
| `@mdx-js/mdx`             | Compile MDX to JS                                                                       | ~250KB                 |
| `gray-matter`             | Parse frontmatter                                                                       | ~30KB                  |
| `rehype-pretty-code`      | Build-time syntax highlighting                                                          | ~20KB                  |
| `shiki`                   | TextMate grammar engine for highlighting                                                | ~2MB (themes+grammars) |
| `remark-frontmatter`      | Strip YAML from MDX pipeline                                                            | ~5KB                   |
| `remark-gfm`              | GitHub Flavored Markdown (tables, etc.)                                                 | ~10KB                  |
| `typedoc`                 | API reference generation                                                                | ?                      |
| `typedoc-plugin-markdown` | TypeDoc → Markdown output                                                               | ?                      |
| `esbuild`                 | Bundle client app + playground modules (todo: is this really necessary if we have bun?) | ?                      |
| `esbuild-wasm`            | Client-side TSX transpilation                                                           | ?                      |
| `@codemirror/*`           | Code editor for playgrounds                                                             | ?                      |

All are build-time only (except esbuild-wasm and CodeMirror which are client-side for playgrounds).

---

## Verification

1. `bun run docs:build` → generates static site in `dist/`
2. `bun run docs:dev` → dev server at localhost with livereload
3. Pages render with sidebar, navigation, content, syntax-highlighted code
4. Theme toggle works and persists across page loads
5. Debug UI toggles on every page, shows ECS entities/systems
6. Interactive playgrounds: edit code → live preview updates
7. `bun run check:full` → existing tests and types still pass

---

## Critical Files

| File                                      | Role                                                    |
| ----------------------------------------- | ------------------------------------------------------- |
| `packages/ecs/src/jsx-runtime.ts`         | JSX factory for client-side ECS app                     |
| `packages/ecs/src/materialize.ts`         | Bridges JSX → ECS entities                              |
| `packages/dom/src/features/debug-ui/`     | Debug UI — mounted on every doc page                    |
| `packages/dom/src/dom-element-systems.ts` | Core DOM system — getDOMElement for innerHTML injection |
| `apps/playground/src/main.tsx`            | Reference init pattern, can probbably be improved upon  |
