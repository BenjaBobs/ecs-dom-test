/**
 * Bundle definitions - reusable groups of components.
 * @module
 */

import type { ComponentInstance, ComponentRef } from './component.ts';
import { getTag } from './component.ts';

/**
 * Result of evaluating a bundle - contains the generated component instances.
 */
export type BundleResult = {
  /** Marker to identify bundle results */
  _isBundle: true;
  /** The component instances generated by the bundle */
  components: ComponentInstance[];
};

/**
 * A bundle function that generates component instances from props.
 *
 * @typeParam P - The props type for the bundle
 */
export type BundleFn<P> = (
  props: P & {
    /** Exclude these components from the bundle */
    except?: ComponentRef[];
    /** Only include these components from the bundle */
    only?: ComponentRef[];
  },
) => BundleResult;

/**
 * Define a bundle - a reusable group of components.
 * Bundles allow you to create common component combinations that can be
 * customized with `except` or `only` filters.
 *
 * @typeParam P - The props type for the bundle
 * @param fn - Function that generates component instances from props
 * @returns A bundle function that can be used in JSX or materialize
 *
 * @example
 * ```typescript
 * const RadioOption = defineBundle(({ value }: { value: string }) => [
 *   Clickable(),
 *   Value({ of: value }),
 * ]);
 *
 * // Use all components
 * RadioOption({ value: "a" })
 *
 * // Exclude specific components
 * RadioOption({ value: "a", except: [Clickable] })
 *
 * // Include only specific components
 * RadioOption({ value: "a", only: [Value] })
 * ```
 */
export function defineBundle<P extends Record<string, unknown>>(
  fn: (props: P) => ComponentInstance[],
): BundleFn<P> {
  return (props: P & { except?: ComponentRef[]; only?: ComponentRef[] }): BundleResult => {
    const { except, only, ...rest } = props;
    let components = fn(rest as P);

    if (only && only.length > 0) {
      const onlyTags = only.map(getTag);
      components = components.filter(c => onlyTags.includes(c._tag));
    } else if (except && except.length > 0) {
      const exceptTags = except.map(getTag);
      components = components.filter(c => !exceptTags.includes(c._tag));
    }

    return {
      _isBundle: true,
      components,
    };
  };
}

/**
 * Check if a value is a bundle result.
 *
 * @param value - The value to check
 * @returns True if the value is a BundleResult
 */
export function isBundle(value: unknown): value is BundleResult {
  return (
    typeof value === 'object' && value != null && '_isBundle' in value && value._isBundle === true
  );
}
